import { useCallback, useContext, useState, useMemo, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { dashboardContext, nullAccount } from '@context'
import { Choice, Switch, Dropdown, Request } from '@utils'
import { MIN_YEAR, MAX_YEAR, TOO_MANY_REQS_MSG } from '@const'
import { parseAccount } from '@auth'
import type { WeekendDays, InputEvent, AccountResponse } from '@types'
// import type { WeekendDays, InputEvent, Interval, AccountResponse } from '@types'
import Sidebar from '../_Sidebar'
import LoadingScreen from '@/components/_LoadingScreen'

const Account = () => {
    const router = useRouter()
    const { account, setAccount, employees, shifts, schedules, holidays, openModal, closeModal, setModalContent } = useContext(dashboardContext)
    const [exitingAccount, setExitingAccount] = useState(false)
    const exitAccount = useCallback(() => {
        closeModal()
        setExitingAccount(true)
        window.location.reload()
        document.documentElement.classList.remove('dark-theme')
    }, [closeModal, setExitingAccount])

    /** Counts the total number of schedules generated by the account */
    const countSchedules = useCallback(() => {
        let count = 0
        for (let year = MIN_YEAR; year <= MAX_YEAR; year++) {
            const schedulesOfYear = schedules.get(year)
            if (schedulesOfYear === undefined) continue
            for (let j = 0; j < schedulesOfYear.length; j++) count += schedulesOfYear[j] ? 1 : 0
        }
        return count
    }, [schedules])

    // Memoized account stats
    const employeeCountText = useMemo(() => `${employees.length} pediatrician${employees.length === 1 ? '' : 's'} registered`, [employees.length])
    const shiftCountText = useMemo(() => `${shifts.length} shift${shifts.length === 1 ? '' : 's'} assigned per day`,[shifts.length])
    const scheduleCountText = useMemo(() => {
        const numSchedules = countSchedules()
        return `${numSchedules} schedule${numSchedules === 1 ? '' : 's'} generated`
    }, [countSchedules])
    const holidayCountText = useMemo(() => `${holidays.length} holiday${holidays.length === 1 ? '' : 's'} assigned`, [holidays.length])
    const emailVerifiedText = useMemo(() => `Email is ${account.emailVerified ? '' : 'not'} verified`,  [account.emailVerified])

    /** Logs out of the account */
    const logOut = useCallback(async () => {
        exitAccount()
        await new Request(
            `auth/logout`,
            () => { setAccount(nullAccount); router.push('/dashboard') }
        ).get()
    }, [router, setAccount, exitAccount])

    /** Displays an account deletion modal. If confirmed, sends an API request to delete the account */
    const openDeleteModal = useCallback(() => {
        const DeleteAccountModalContent = () => {
            const [error, setError] = useState('')

            const deleteAccount = useCallback(async () => {
                exitAccount()
                await new Request(
                    'accounts',
                    async () => await logOut(),
                    (error) => {
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(
                            error.includes('Invalid cookies') ?
                            'Account session has expired. Please log out then log in again to delete your account.'
                            : error
                        )
                    }
                ).delete()
            }, [])

            return <>
                <h1>Delete Your Account?</h1>
                <p>This action cannot be undone. Are you sure you want to delete it?</p>
                {error && <p className='error'>{error}</p>}
                <Choice onYes={deleteAccount} onNo={closeModal}/>
            </>
        }
        setModalContent(<DeleteAccountModalContent/>)
        openModal()
    }, [logOut, closeModal, openModal, setModalContent, exitAccount])

    /** Displays a modal for confirming log-out */
    const openLogOutModal = useCallback(() => {
        setModalContent(<>
            <h1>Log Out?</h1>
            <p>You can log in back again later.</p>
            <Choice onYes={logOut} onNo={closeModal}/>
        </>)
        openModal()
    }, [logOut, closeModal, openModal, setModalContent])

    /** Displays a modal for editing the account's email */
    const openChangeEmailModal = useCallback(() => {
        const ChangeEmailModalContent = () => {
            const [tempEmail, setTempEmail] = useState(account.email)
            const [isConfirmDisabled, setConfirmDisabled] = useState(tempEmail.trim().length < 3 || account.email === tempEmail)
            const [error, setError] = useState('')

            const handleEmailChange = (e: InputEvent) => {
                const newEmail = e.target.value
                setTempEmail(newEmail)
                setConfirmDisabled(newEmail.trim().length < 1 || account.email === newEmail)
            }

            const confirmEdit = async () => {
                await new Request(
                    'accounts/email',
                    (data: AccountResponse) => {
                        setAccount(parseAccount(data))
                        closeModal()
                    },
                    (error) => {
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(
                            error.includes('Invalid cookies') 
                            ? 'Account session has expired. Please log out then log in again to update your email.'
                            : error
                        )
                    }
                ).patch({ email: tempEmail })
            }

            return <>
                <h2>Change Email</h2>
                <section style={{ marginBottom: 20 }}>
                    <label style={{ marginRight: 10 }}>Email: </label>
                    <input
                        type='text'
                        placeholder='New email'
                        value={tempEmail}
                        onChange={handleEmailChange}
                        maxLength={32}
                    />
                </section>
                {error && <p className='error'>{error}</p>}
                <button
                    onClick={confirmEdit}
                    disabled={isConfirmDisabled}
                    id={isConfirmDisabled ? 'disabled-confirm-btn' : ''}
                >
                    Confirm
                </button>
            </>
        }

        setModalContent(<ChangeEmailModalContent/>)
        openModal()
    }, [account, setAccount, openModal, closeModal, setModalContent])

    /** Displays a modal for creating a new password */
    const openChangePasswordModal = useCallback(() => {
        const ChangePasswordModalContent = () => {
            const [tempCurrentPassword, setCurrentPassword] = useState('')
            const [tempNewPassword, setNewPassword] = useState('')
            const [tempConfirmPassword, setConfirmPassword] = useState('')
            const [isConfirmDisabled, setConfirmDisabled] = useState(true)
            const [error, setError] = useState('')

            const validateInputs = (current: string, newPass: string, confirmPass: string) => {
                setConfirmDisabled(
                    current.trim().length < 3 ||
                    newPass.trim().length < 3 ||
                    confirmPass.trim().length < 3
                )
            }

            const handleCurrentPasswordChange = (e: InputEvent) => {
                const currentPassword = e.target.value
                setCurrentPassword(currentPassword)
                validateInputs(currentPassword, tempNewPassword, tempConfirmPassword)
            }

            const handleNewPasswordChange = (e: InputEvent) => {
                const newPassword = e.target.value
                setNewPassword(newPassword)
                validateInputs(tempCurrentPassword, newPassword, tempConfirmPassword)
            }

            const handleConfirmPasswordChange = (e: InputEvent) => {
                const confirmPassword = e.target.value
                setConfirmPassword(confirmPassword)
                validateInputs(tempCurrentPassword, tempNewPassword, confirmPassword)
            }

            const confirmEdit = async () => {
                if (tempNewPassword.trim() !== tempConfirmPassword.trim()) {
                    setError('Make sure both entered passwords exactly match.')
                    return
                }

                await new Request(
                    'accounts/password',
                    (data: AccountResponse) => {
                        setAccount(parseAccount(data))
                        closeModal()
                    },
                    (error) => {
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(
                            error.includes('Invalid cookies') 
                            ? 'Session has expired. Please log out then log in again to update your password.'
                            : error
                        )
                    }
                ).patch({ 
                    current_password: tempCurrentPassword,
                    new_password: tempNewPassword 
                })
            }

            return <>
                <h2>Change Password</h2>
                
                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>Current password: </label>
                    <input
                        type='password'
                        placeholder='Current password'
                        value={tempCurrentPassword}
                        onChange={handleCurrentPasswordChange}
                        maxLength={32}
                    />
                </section>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>New password: </label>
                    <input
                        type='password'
                        placeholder='New password'
                        value={tempNewPassword}
                        onChange={handleNewPasswordChange}
                        maxLength={32}
                    />
                </section>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>Confirm password: </label>
                    <input
                        type='password'
                        placeholder='Confirm password'
                        value={tempConfirmPassword}
                        onChange={handleConfirmPasswordChange}
                        maxLength={32}
                    />
                </section>

                {error && <p className='error'>{error}</p>}

                <button
                    onClick={confirmEdit}
                    disabled={isConfirmDisabled}
                    id={isConfirmDisabled ? 'disabled-confirm-btn' : ''}
                >
                    Confirm
                </button>
            </>
        }

        setModalContent(<ChangePasswordModalContent/>)
        openModal()
    }, [setAccount, openModal, closeModal, setModalContent])

    /** Displays a modal for setting a new password (OAuth-only users) */
    const openSetPasswordModal = useCallback(() => {
        const SetPasswordModalContent = () => {
            const [tempNewPassword, setNewPassword] = useState('')
            const [tempConfirmPassword, setConfirmPassword] = useState('')
            const [isConfirmDisabled, setConfirmDisabled] = useState(true)
            const [error, setError] = useState('')

            const validateInputs = (newPass: string, confirmPass: string) => {
                setConfirmDisabled(newPass.trim().length < 3 || confirmPass.trim().length < 3)
            }

            const handleNewPasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
                const newPassword = e.target.value
                setNewPassword(newPassword)
                validateInputs(newPassword, tempConfirmPassword)
            }

            const handleConfirmPasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
                const confirmPassword = e.target.value
                setConfirmPassword(confirmPassword)
                validateInputs(tempNewPassword, confirmPassword)
            }

            const confirmEdit = async () => {
                if (tempNewPassword.trim() !== tempConfirmPassword.trim()) {
                    setError('Make sure both entered passwords exactly match.')
                    return
                }

                await new Request(
                    'accounts/password',
                    (data: AccountResponse) => {
                        setAccount(parseAccount(data))
                        closeModal()
                    },
                    (error) => {
                        if (error.includes('429')) {
                            setError(TOO_MANY_REQS_MSG)
                            return
                        }
                        setError(
                            error.includes('Invalid cookies') 
                            ? 'Session has expired. Please log out then log in again to set your password.'
                            : error
                        )
                    }
                ).patch({ new_password: tempNewPassword })
            }

            return <>
                <h2>Set Password</h2>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>New password: </label>
                    <input
                        type='password'
                        placeholder='New password'
                        value={tempNewPassword}
                        onChange={handleNewPasswordChange}
                        maxLength={32}
                    />
                </section>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>Confirm password: </label>
                    <input
                        type='password'
                        placeholder='Confirm password'
                        value={tempConfirmPassword}
                        onChange={handleConfirmPasswordChange}
                        maxLength={32}
                    />
                </section>

                {error && <p className='error'>{error}</p>}

                <button
                    onClick={confirmEdit}
                    disabled={isConfirmDisabled}
                    id={isConfirmDisabled ? 'disabled-confirm-btn' : ''}
                >
                    Set Password
                </button>
            </>
        }

        setModalContent(<SetPasswordModalContent/>)
        openModal()
    }, [setAccount, openModal, closeModal, setModalContent])


    /** Displays a modal for verifying the account's email */
    const openVerifyEmailModal = useCallback(() => {
        const VerifyEmailModalContent = () => {
            const [error, setError] = useState<string|null>(null)
            const [isLoading, setIsLoading] = useState(false)

            const requestVerifyEmail = async () => {
                setIsLoading(true)
                await new Request(
                    'auth/request_verify_email',
                    () => setIsLoading(false),
                    (error) => {
                        setIsLoading(false)
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(error)
                    }
                ).post({ email: account.email })
            }

            useEffect(() => { requestVerifyEmail() }, [])

            return <>
                <h1>Verify Your Email</h1>
                <p>
                    {
                        isLoading 
                        ? 'Sending email verification request...'
                        : error || 'We have sent you an email verification request to your email. Please check your inbox and follow the instructions to verify your email.'
                    }
                </p>
            </>
        }
    
        setModalContent(<VerifyEmailModalContent/>)
        openModal()
    }, [account.email, openModal, setModalContent])

    return exitingAccount ? <LoadingScreen/> : (
        <section id='account-card' className='settings-card'>
            <h3 className='settings-title'>Account</h3>
            <div className='card-content'>
                <section>
                    <h1>{account.email}</h1>
                    <ul>
                        <li>{scheduleCountText}</li>
                        <li>{employeeCountText}</li>
                        <li>{shiftCountText}</li>
                        <li>{holidayCountText}</li>
                        <li>{emailVerifiedText}</li>
                    </ul>
                </section>
                <section id='account-actions-card'>
                    {!account.emailVerified && <button id='verify-email-btn' onClick={openVerifyEmailModal}>Verify Email</button>}
                    <button className='edit-account-btn' onClick={openChangeEmailModal}>Change Email</button>
                    <button className='edit-account-btn' onClick={account.isOAuthOnly ? openSetPasswordModal : openChangePasswordModal}>
                        {account.isOAuthOnly ? 'Set Password' : 'Change Password'}
                    </button>
                    <button id='log-out-btn' onClick={openLogOutModal}>Log Out</button>
                    <button id='delete-account-btn' onClick={openDeleteModal}>Delete Account</button>
                </section>
            </div>
        </section>
    )
}


const PreferencesAndFunctionality = () => {
    const { account, settings, setSettings } = useContext(dashboardContext)
    const [selectedWeekendDays, setSelectedWeekendDays] = useState<WeekendDays>(settings.weekendDays)
    // const [selectedEmailNtfInterval, setSelectedEmailNtfInterval] = useState<Interval>(settings.emailNtfInterval)

    /** Switches between light & dark themes */
    const toggleDarkTheme = async () => {
        await new Request(
            `accounts/${account.id}/settings/toggle_dark_theme`,
            (data: { detail: boolean|null }) => setSettings(prev => ({...prev, darkThemeEnabled: data.detail ? true : false }))
        ).get()
    }

    /** Turns on/off advanced mode */
    const toggleMinMaxWorkHours = async () => {
        await new Request(
            `accounts/${account.id}/settings/toggle_min_max_work_hours`,
            (data: { detail: boolean|null }) => setSettings(prev => ({...prev, minMaxWorkHoursEnabled: data.detail ? true : false }))
        ).get()
    }

    /** Allows/Disallows multiple employees to be in a single shift */
    const toggleMultiEmpsInShift = async () => {
        await new Request(
            `accounts/${account.id}/settings/toggle_multi_emps_in_shift`,
            (data: { detail: boolean|null }) => setSettings(prev => ({...prev, multiEmpsInShiftEnabled: data.detail ? true : false }))
        ).get()
    }

    /** Allows/Disallows one employee to take multiple shifts in the same day */
    const toggleMultiShiftsOneEmpEnabled = async () => {
        await new Request(
            `accounts/${account.id}/settings/toggle_multi_shifts_one_emp`,
            (data: { detail: boolean|null }) => setSettings(prev => ({...prev, multiShiftsOneEmpEnabled: data.detail ? true : false }))
        ).get()
    }

    /** Changes the weekend days of the account */
    const changeWeekendDays = async (option: string) => {
        setSelectedWeekendDays(option as WeekendDays)
        await new Request(
            `accounts/${account.id}/settings/update_weekend_days`,
            (data: { detail: WeekendDays }) => setSettings(prev => ({...prev, weekendDays: data.detail }))
        ).patch({ weekend_days: option })
    }

    /** Updates the maximum number of employees in a single shift */
    const updateMaxEmpsInShift = async (e: InputEvent) => {
        if (!settings.multiEmpsInShiftEnabled) return
        const newValue = parseInt(e.target.value, 10)
        await new Request(
            `accounts/${account.id}/settings/max_emps_in_shift`,
            (data: { detail: number }) => setSettings(prev => ({...prev, maxEmpsInShift: data.detail }))   
        ).patch({ max_emps_in_shift: newValue })
    }

    // /** Switches between light & dark themes */
    // const toggleEmailNtf = async () => {
    //     await new Request(
    //         `accounts/${account.id}/settings/toggle_email_ntf`,
    //         (data: { detail: boolean|null }) => setSettings(prev => ({...prev, emailNtfEnabled: data.detail ? true : false }))
    //     ).get()
    // }

    // /** Changes the weekend days of the account */
    // const changeEmailNtfInterval = async (option: string) => {
    //     setSelectedEmailNtfInterval(option as Interval)
    //     await new Request(
    //         `accounts/${account.id}/settings/update_email_ntf_interval`,
    //         (data: { detail: Interval }) => setSettings(prev => ({...prev, emailNtfInterval: data.detail }))
    //     ).patch({ email_ntf_interval: option })
    // }

    return (
        <section id='pref-card' className='settings-card'>
            <h3 className='settings-title'>Preferences & Functionality</h3>
            <div className='card-content'>
                <Switch label='Dark theme' handleClick={toggleDarkTheme} enabled={settings.darkThemeEnabled}/>
                <Dropdown
                    label='Weekend days'
                    options={['Saturday & Sunday', 'Friday & Saturday', 'Sunday & Monday']}
                    selectedOption={selectedWeekendDays}
                    setSelectedOption={changeWeekendDays}
                />
                <div className='horizontal-separator'></div>
                <Switch label='Use minimum & maximum work hours for pediatricians' handleClick={toggleMinMaxWorkHours} enabled={settings.minMaxWorkHoursEnabled}/>
                <Switch label='Allow pediatricians to take multiple shifts in a day' handleClick={toggleMultiShiftsOneEmpEnabled} enabled={settings.multiShiftsOneEmpEnabled}/>
                <Switch label='Allow multiple pediatricians to be in the same shift' handleClick={toggleMultiEmpsInShift} enabled={settings.multiEmpsInShiftEnabled}/>
                <div>
                    <label>Maximum number of pediatricians in one shift</label>
                    <input
                        type='number'
                        min={1} max={10}
                        onChange={updateMaxEmpsInShift}
                        value={settings.multiEmpsInShiftEnabled ? settings.maxEmpsInShift : 1}
                        disabled={!settings.multiEmpsInShiftEnabled}
                        className={!settings.multiEmpsInShiftEnabled ? 'disabled-setting-input' : ''}
                    />
                </div>
                {/* <div className='horizontal-separator'></div>
                <Switch label='Receive e-mail notifications' handleClick={toggleEmailNtf} enabled={settings.emailNtfEnabled}/>
                <Dropdown
                    label='When to send e-mail notifications'
                    options={['Daily', 'Weekly', 'Monthly']}
                    selectedOption={selectedEmailNtfInterval}
                    setSelectedOption={changeEmailNtfInterval}
                /> */}
            </div>
        </section>
    )
}


export default function Settings() {
    return <>
        <Sidebar/>
        <div className='settings-cards'>
            <Account/>
            <PreferencesAndFunctionality/>
        </div>
    </>
}