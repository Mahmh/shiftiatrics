import { useCallback, useContext, useState, useMemo, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { dashboardContext, nullAccount } from '@context'
import { Choice, Switch, Dropdown, Request, NumInput } from '@utils'
import { MIN_YEAR, MAX_YEAR, TOO_MANY_REQS_MSG } from '@const'
import { parseAccount, parseSettings } from '@auth'
import type { WeekendDays, InputEvent, AccountResponse, SettingsResponse, Settings, Shift } from '@types'
import LoadingScreen from '@/components/_LoadingScreen'

export default function Settings() {
    return <div className='settings-cards'>
        <Account/>
        <Preferences/>
        <ScheduleGeneration/>
    </div>
}

const updateSetting = async (setting: string, newValue: number | string | boolean | (string | null)[], accountId: number): Promise<Settings> => {
    return await new Request(
        `accounts/${accountId}/settings`,
        (data: SettingsResponse) => parseSettings(data)
    ).patch({ setting: setting, new_value: newValue })
}

export const RotationPatternEditor = ({ shifts, days=7, onChange }: { shifts: Shift[], days?: number, onChange?: (pattern: (string | null)[]) => void }) => {
    const { account, settings, setSettings } = useContext(dashboardContext)
    const [rotationPattern, setRotationPattern] = useState<(string | null)[]>(settings.rotationPattern)
    
    useEffect(() => {
        // Adjust pattern when day count changes
        setRotationPattern(prev => {
            if (days > prev.length) return [...prev, ...Array(days - prev.length).fill(null)]
            if (days < prev.length) return prev.slice(0, days)
            return prev
        })
    }, [days])

    useEffect(() => {
        const updatePattern = async () => setSettings(await updateSetting('rotation_pattern', rotationPattern, account.id))
        updatePattern()
    }, [rotationPattern, setSettings, account.id])

    const handleChange = (index: number, value: string) => {
        const updated = [...rotationPattern]
        updated[index] = value === 'OFF' ? null : value
        setRotationPattern(updated)
        onChange?.(updated)
    }

    return (
        <div id='rotation-pattern-editor'>
            <label>Rotation pattern</label>
            <div>
                {rotationPattern.map((value, i) => (
                    <Dropdown
                        key={i}
                        label={`Day ${i+1}`}
                        options={['OFF', ...shifts.map(s => s.name)]}
                        selectedOption={value ?? 'OFF'}
                        setSelectedOption={val => handleChange(i, val)}
                    />
                ))}
            </div>
        </div>
    )
}


// Cards
const Account = () => {
    const router = useRouter()
    const { account, setAccount, setSubscription, employees, shifts, schedules, holidays, openModal, closeModal, setModalContent } = useContext(dashboardContext)
    const [exitingAccount, setExitingAccount] = useState(false)
    const exitAccount = useCallback(() => {
        closeModal()
        setExitingAccount(true)
        window.location.reload()
        document.documentElement.classList.remove('dark-theme')
    }, [closeModal, setExitingAccount])

    /** Counts the total number of schedules generated by the account */
    const countSchedules = useCallback(() => {
        let count = 0
        for (let year = MIN_YEAR; year <= MAX_YEAR; year++) {
            const schedulesOfYear = schedules.get(year)
            if (schedulesOfYear === undefined) continue
            for (let j = 0; j < schedulesOfYear.length; j++) count += schedulesOfYear[j] ? 1 : 0
        }
        return count
    }, [schedules])

    // Memoized account stats
    const employeeCountText = useMemo(() => `${employees.length} pediatrician${employees.length === 1 ? '' : 's'} registered`, [employees.length])
    const shiftCountText = useMemo(() => `${shifts.length} shift${shifts.length === 1 ? '' : 's'} assigned per day`,[shifts.length])
    const scheduleCountText = useMemo(() => {
        const numSchedules = countSchedules()
        return `${numSchedules} schedule${numSchedules === 1 ? '' : 's'} generated`
    }, [countSchedules])
    const holidayCountText = useMemo(() => `${holidays.length} holiday${holidays.length === 1 ? '' : 's'} assigned`, [holidays.length])
    const emailVerifiedText = useMemo(() => `Email is ${account.emailVerified ? '' : 'not'} verified`,  [account.emailVerified])

    /** Logs out of the account */
    const logOut = useCallback(async () => {
        exitAccount()
        await new Request(
            `auth/logout`,
            () => {
                setAccount(nullAccount)
                setSubscription(null)
                router.push('/dashboard')
            }
        ).get()
    }, [router, setAccount, exitAccount, setSubscription])

    /** Displays an account deletion modal. If confirmed, sends an API request to delete the account */
    const openDeleteModal = useCallback(() => {
        const DeleteAccountModalContent = () => {
            const [error, setError] = useState('')

            const deleteAccount = useCallback(async () => {
                exitAccount()
                await new Request(
                    'accounts',
                    async () => await logOut(),
                    (error) => {
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(
                            error.includes('Invalid cookies') ?
                            'Account session has expired. Please log out then log in again to delete your account.'
                            : error
                        )
                    }
                ).delete()
            }, [])

            return <>
                <h1>Delete Your Account?</h1>
                <p>
                    Are you sure you want to permanently delete your account?
                    <b> This action is irreversible</b> and will automatically cancel your active subscription.
                </p>
                {error && <p className='error'>{error}</p>}
                <Choice onYes={deleteAccount} onNo={closeModal}/>
            </>
        }
        setModalContent(<DeleteAccountModalContent/>)
        openModal()
    }, [logOut, closeModal, openModal, setModalContent, exitAccount])

    /** Displays a modal for confirming log-out */
    const openLogOutModal = useCallback(() => {
        setModalContent(<>
            <h1>Log Out?</h1>
            <p>You can log in back again later.</p>
            <Choice onYes={logOut} onNo={closeModal}/>
        </>)
        openModal()
    }, [logOut, closeModal, openModal, setModalContent])

    /** Displays a modal for editing the account's email */
    const openChangeEmailModal = useCallback(() => {
        const ChangeEmailModalContent = () => {
            const [tempEmail, setTempEmail] = useState(account.email)
            const [isConfirmDisabled, setConfirmDisabled] = useState(tempEmail.trim().length < 3 || account.email === tempEmail)
            const [error, setError] = useState('')

            const handleEmailChange = (e: InputEvent) => {
                const newEmail = e.target.value
                setTempEmail(newEmail)
                setConfirmDisabled(newEmail.trim().length < 1 || account.email === newEmail)
            }

            const confirmEdit = async () => {
                await new Request(
                    'accounts/email',
                    (data: AccountResponse) => {
                        setAccount(parseAccount(data))
                        closeModal()
                    },
                    (error) => {
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(
                            error.includes('Invalid cookies') 
                            ? 'Account session has expired. Please log out then log in again to update your email.'
                            : error
                        )
                    }
                ).patch({ email: tempEmail })
            }

            return <>
                <h2>Change Email</h2>
                <section style={{ marginBottom: 20 }}>
                    <label style={{ marginRight: 10 }}>Email: </label>
                    <input
                        type='text'
                        placeholder='New email'
                        value={tempEmail}
                        onChange={handleEmailChange}
                        maxLength={32}
                    />
                </section>
                {error && <p className='error'>{error}</p>}
                <button
                    onClick={confirmEdit}
                    disabled={isConfirmDisabled}
                    id={isConfirmDisabled ? 'disabled-confirm-btn' : ''}
                >
                    Confirm
                </button>
            </>
        }

        setModalContent(<ChangeEmailModalContent/>)
        openModal()
    }, [account, setAccount, openModal, closeModal, setModalContent])

    /** Displays a modal for creating a new password */
    const openChangePasswordModal = useCallback(() => {
        const ChangePasswordModalContent = () => {
            const [tempCurrentPassword, setCurrentPassword] = useState('')
            const [tempNewPassword, setNewPassword] = useState('')
            const [tempConfirmPassword, setConfirmPassword] = useState('')
            const [isConfirmDisabled, setConfirmDisabled] = useState(true)
            const [error, setError] = useState('')

            const validateInputs = (current: string, newPass: string, confirmPass: string) => {
                setConfirmDisabled(
                    current.trim().length < 3 ||
                    newPass.trim().length < 3 ||
                    confirmPass.trim().length < 3
                )
            }

            const handleCurrentPasswordChange = (e: InputEvent) => {
                const currentPassword = e.target.value
                setCurrentPassword(currentPassword)
                validateInputs(currentPassword, tempNewPassword, tempConfirmPassword)
            }

            const handleNewPasswordChange = (e: InputEvent) => {
                const newPassword = e.target.value
                setNewPassword(newPassword)
                validateInputs(tempCurrentPassword, newPassword, tempConfirmPassword)
            }

            const handleConfirmPasswordChange = (e: InputEvent) => {
                const confirmPassword = e.target.value
                setConfirmPassword(confirmPassword)
                validateInputs(tempCurrentPassword, tempNewPassword, confirmPassword)
            }

            const confirmEdit = async () => {
                if (tempNewPassword.trim() !== tempConfirmPassword.trim()) {
                    setError('Make sure both entered passwords exactly match.')
                    return
                }

                await new Request(
                    'accounts/password',
                    (data: AccountResponse) => {
                        setAccount(parseAccount(data))
                        closeModal()
                    },
                    (error) => {
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(
                            error.includes('Invalid cookies') 
                            ? 'Session has expired. Please log out then log in again to update your password.'
                            : error
                        )
                    }
                ).patch({ 
                    current_password: tempCurrentPassword,
                    new_password: tempNewPassword 
                })
            }

            return <>
                <h2>Change Password</h2>
                
                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>Current password: </label>
                    <input
                        type='password'
                        placeholder='Current password'
                        value={tempCurrentPassword}
                        onChange={handleCurrentPasswordChange}
                        maxLength={32}
                    />
                </section>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>New password: </label>
                    <input
                        type='password'
                        placeholder='New password'
                        value={tempNewPassword}
                        onChange={handleNewPasswordChange}
                        maxLength={32}
                    />
                </section>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>Confirm password: </label>
                    <input
                        type='password'
                        placeholder='Confirm password'
                        value={tempConfirmPassword}
                        onChange={handleConfirmPasswordChange}
                        maxLength={32}
                    />
                </section>

                {error && <p className='error'>{error}</p>}

                <button
                    onClick={confirmEdit}
                    disabled={isConfirmDisabled}
                    id={isConfirmDisabled ? 'disabled-confirm-btn' : ''}
                >
                    Confirm
                </button>
            </>
        }

        setModalContent(<ChangePasswordModalContent/>)
        openModal()
    }, [setAccount, openModal, closeModal, setModalContent])

    /** Displays a modal for setting a new password (OAuth-only users) */
    const openSetPasswordModal = useCallback(() => {
        const SetPasswordModalContent = () => {
            const [tempNewPassword, setNewPassword] = useState('')
            const [tempConfirmPassword, setConfirmPassword] = useState('')
            const [isConfirmDisabled, setConfirmDisabled] = useState(true)
            const [error, setError] = useState('')

            const validateInputs = (newPass: string, confirmPass: string) => {
                setConfirmDisabled(newPass.trim().length < 3 || confirmPass.trim().length < 3)
            }

            const handleNewPasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
                const newPassword = e.target.value
                setNewPassword(newPassword)
                validateInputs(newPassword, tempConfirmPassword)
            }

            const handleConfirmPasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
                const confirmPassword = e.target.value
                setConfirmPassword(confirmPassword)
                validateInputs(tempNewPassword, confirmPassword)
            }

            const confirmEdit = async () => {
                if (tempNewPassword.trim() !== tempConfirmPassword.trim()) {
                    setError('Make sure both entered passwords exactly match.')
                    return
                }

                await new Request(
                    'accounts/password',
                    (data: AccountResponse) => {
                        setAccount(parseAccount(data))
                        closeModal()
                    },
                    (error) => {
                        if (error.includes('429')) {
                            setError(TOO_MANY_REQS_MSG)
                            return
                        }
                        setError(
                            error.includes('Invalid cookies') 
                            ? 'Session has expired. Please log out then log in again to set your password.'
                            : error
                        )
                    }
                ).patch({ new_password: tempNewPassword })
            }

            return <>
                <h2>Set Password</h2>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>New password: </label>
                    <input
                        type='password'
                        placeholder='New password'
                        value={tempNewPassword}
                        onChange={handleNewPasswordChange}
                        maxLength={32}
                    />
                </section>

                <section className='modal-input-sec'>
                    <label style={{ marginRight: 10 }}>Confirm password: </label>
                    <input
                        type='password'
                        placeholder='Confirm password'
                        value={tempConfirmPassword}
                        onChange={handleConfirmPasswordChange}
                        maxLength={32}
                    />
                </section>

                {error && <p className='error'>{error}</p>}

                <button
                    onClick={confirmEdit}
                    disabled={isConfirmDisabled}
                    id={isConfirmDisabled ? 'disabled-confirm-btn' : ''}
                >
                    Set Password
                </button>
            </>
        }

        setModalContent(<SetPasswordModalContent/>)
        openModal()
    }, [setAccount, openModal, closeModal, setModalContent])


    /** Displays a modal for verifying the account's email */
    const openVerifyEmailModal = useCallback(() => {
        const VerifyEmailModalContent = () => {
            const [error, setError] = useState<string|null>(null)
            const [loading, setLoading] = useState(false)

            const requestVerifyEmail = async () => {
                setLoading(true)
                await new Request(
                    'auth/request_verify_email',
                    () => setLoading(false),
                    (error) => {
                        setLoading(false)
                        if (error.includes('429')) { setError(TOO_MANY_REQS_MSG); return }
                        setError(error)
                    }
                ).post({ email: account.email })
            }

            useEffect(() => { requestVerifyEmail() }, [])

            return <>
                <h1>Verify Your Email</h1>
                <p>
                    {
                        loading 
                        ? 'Sending email verification request...'
                        : error || 'We have sent you an email verification request to your email. Please check your inbox and follow the instructions to verify your email.'
                    }
                </p>
            </>
        }
    
        setModalContent(<VerifyEmailModalContent/>)
        openModal()
    }, [account.email, openModal, setModalContent])

    return exitingAccount ? <LoadingScreen/> : (
        <section id='account-card' className='settings-card'>
            <h3 className='settings-title'>Account</h3>
            <div className='card-content'>
                <section>
                    <h1>{account.email}</h1>
                    <ul>
                        <li>{scheduleCountText}</li>
                        <li>{employeeCountText}</li>
                        <li>{shiftCountText}</li>
                        <li>{holidayCountText}</li>
                        <li>{emailVerifiedText}</li>
                    </ul>
                </section>
                <section id='account-actions-card'>
                    {!account.emailVerified && <button id='verify-email-btn' onClick={openVerifyEmailModal}>Verify Email</button>}
                    <button className='edit-account-btn' onClick={openChangeEmailModal}>Change Email</button>
                    <button className='edit-account-btn' onClick={account.isOAuthOnly ? openSetPasswordModal : openChangePasswordModal}>
                        {account.isOAuthOnly ? 'Set Password' : 'Change Password'}
                    </button>
                    <button id='log-out-btn' onClick={openLogOutModal}>Log Out</button>
                    <button id='delete-account-btn' onClick={openDeleteModal}>Delete Account</button>
                </section>
            </div>
        </section>
    )
}


const Preferences = () => {
    const { account, settings, setSettings } = useContext(dashboardContext)
    const [selectedWeekendDays, setSelectedWeekendDays] = useState<WeekendDays>(settings.weekendDays)
    // const [selectedEmailNtfInterval, setSelectedEmailNtfInterval] = useState<Interval>(settings.emailNtfInterval)

    /** Changes the weekend days of the account */
    const changeWeekendDays = async (option: string) => {
        setSettings(await updateSetting('weekend_days', option, account.id))
        setSelectedWeekendDays(option as WeekendDays)
    }

    // /** Changes email notification sending interval */
    // const changeEmailNtfInterval = async (option: string) => {
    //     setSettings(await updateSetting('email_ntf_interval', option, account.id))
    //     setSelectedEmailNtfInterval(option as Interval)
    // }

    return (
        <section className='settings-card'>
            <h3 className='settings-title'>Preferences</h3>
            <div className='card-content'>
                <Switch
                    label='Dark theme'
                    handleClick={async () => setSettings(await updateSetting('dark_theme_enabled', !settings.darkThemeEnabled, account.id))}
                    enabled={settings.darkThemeEnabled}
                />
                <Dropdown
                    label='Weekend days'
                    options={['Saturday & Sunday', 'Friday & Saturday', 'Sunday & Monday']}
                    selectedOption={selectedWeekendDays}
                    setSelectedOption={changeWeekendDays}
                />
                {/*<div className='horizontal-separator'></div>
                <Switch
                    label='Receive e-mail notifications'
                    handleClick={async () => setSettings(await updateSetting('email_ntf_enabled', !settings.emailNtfEnabled, account.id))}
                    enabled={settings.emailNtfEnabled}
                />
                <Dropdown
                    label='When to send e-mail notifications'
                    options={['Daily', 'Weekly', 'Monthly']}
                    selectedOption={selectedEmailNtfInterval}
                    setSelectedOption={changeEmailNtfInterval}
                /> */}
            </div>
        </section>
    )
}


const ScheduleGeneration = () => {
    const { account, shifts, settings, setSettings } = useContext(dashboardContext)
    const [patternDayCount, setPatternDayCount] = useState(settings.rotationPattern?.length ?? 5)

    const handlePatternDayCountChange = async (newValue: number) => {
        setPatternDayCount(newValue)

        const oldPattern = settings.rotationPattern ?? []
        const updatedPattern = oldPattern.length < newValue
            ? [...oldPattern, ...Array(newValue - oldPattern.length).fill(null)]
            : oldPattern.slice(0, newValue)

        const updatedSettings = await updateSetting('rotation_pattern', updatedPattern, account.id)
        setSettings(updatedSettings)
    }

    return (
        <section className='settings-card'>
            <h3 className='settings-title'>Schedule Generation</h3>
            <div className='card-content'>
                <Switch
                    label='Avoid assigning an employee to a night shift two days in a row'
                    handleClick={async () => setSettings(await updateSetting('avoid_back_to_back_nights', !settings.avoidBackToBackNights, account.id))}
                    enabled={settings.avoidBackToBackNights}
                />
                <Switch
                    label='Allow pediatricians to take multiple shifts in a day'
                    handleClick={async () => setSettings(await updateSetting('multi_shifts_one_emp', !settings.multiShiftsOneEmp, account.id))}
                    enabled={settings.multiShiftsOneEmp}
                />
                <NumInput
                    label='Maximum number of pediatricians in one shift'
                    initialValue={settings.maxEmpsInShift}
                    max={10}
                    onChange={async newValue => setSettings(await updateSetting('max_emps_in_shift', newValue, account.id))}
                />
                <NumInput
                    label='Maximum number of shifts an employee can take per week'
                    initialValue={settings.maxShiftsPerWeek}
                    max={12}
                    onChange={async newValue => setSettings(await updateSetting('max_shifts_per_week', newValue, account.id))}
                />
                <div className='horizontal-separator'></div>
                <Switch
                    label='Use a consistent shift rotation pattern'
                    handleClick={async () => setSettings(await updateSetting('use_rotation_pattern', !settings.useRotationPattern, account.id))}
                    enabled={settings.useRotationPattern}
                />
                {settings.useRotationPattern && 
                    <NumInput
                        label='Number of days that the rotation pattern consists of'
                        initialValue={patternDayCount}
                        max={10}
                        onChange={handlePatternDayCountChange}
                    />
                }
                {settings.useRotationPattern && <RotationPatternEditor shifts={shifts} days={patternDayCount}/>}
            </div>
        </section>
    )
}